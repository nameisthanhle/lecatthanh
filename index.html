<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Infinite Table — Always-Live World Pan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #f6f6f6; }
    canvas { display: block; }
    /* Fake crosshair at the center (we hide the OS cursor) */
    .crosshair {
      position: fixed; left: 50%; top: 50%;
      width: 24px; height: 24px; transform: translate(-50%,-50%);
      pointer-events: none; opacity: 0.6;
    }
    .crosshair::before, .crosshair::after {
      content: ""; position: absolute; background: #222;
    }
    .crosshair::before { left: 50%; top: 0; width: 2px; height: 100%; transform: translateX(-50%); }
    .crosshair::after { top: 50%; left: 0; height: 2px; width: 100%; transform: translateY(-50%); }
    /* On pointer lock we hide the system cursor */
    body.locked { cursor: none; }
    /* Minimal overlay to request pointer lock (required by browsers) */
    .hint {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: rgba(255,255,255,0.9); color: #111; font: 16px/1.4 system-ui, sans-serif;
      text-align: center; padding: 24px;
    }
    .hint.hidden { display: none; }
    .hint button {
      margin-top: 12px; padding: 10px 16px; border: 0; border-radius: 8px;
      background: #111; color: #fff; font-weight: 600; cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="hint" class="hint">
    <div>
      <div><strong>Click “Enter”</strong> to lock the cursor and slide the world with your mouse.</div>
      <div>Scroll to zoom · ESC to release</div>
      <button id="enterBtn">Enter</button>
    </div>
  </div>
  <div class="crosshair" aria-hidden="true"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    // --- Scene / Camera / Renderer ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 100000);
    camera.position.set(0, 900, 1200);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // A world group that we slide around
    const world = new THREE.Group();
    scene.add(world);

    // --- Infinite-ish “table” plane (huge with tiling texture) ---
    const loader = new THREE.TextureLoader();
    const gridTex = loader.load("https://threejs.org/examples/textures/uv_grid_opengl.jpg");
    gridTex.wrapS = gridTex.wrapT = THREE.RepeatWrapping;
    gridTex.repeat.set(800, 800);
    gridTex.anisotropy = 8;

    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(200000, 200000, 1, 1),
      new THREE.MeshBasicMaterial({ map: gridTex })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = 0;
    world.add(plane);

    // --- Drop a few sample images as “prints” on the table ---
    function addImage(url, x, z, w = 600, h = 400, rotDeg = 0) {
      const tex = loader.load(url);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
      const geo = new THREE.PlaneGeometry(w, h);
      const m = new THREE.Mesh(geo, mat);
      m.rotation.x = -Math.PI / 2;
      m.rotation.z = THREE.MathUtils.degToRad(rotDeg);
      m.position.set(x, 1, z);
      world.add(m);
      return m;
    }

    // Replace with your artwork URLs
    addImage("https://picsum.photos/seed/a/800/600",   0,    0,   800, 600, -6);
    addImage("https://picsum.photos/seed/b/700/500", 1200, -400, 700, 500, 12);
    addImage("https://picsum.photos/seed/c/900/700", -1400, 800, 900, 700, -15);
    addImage("https://picsum.photos/seed/d/600/800",  600, 1400, 600, 800, 8);

    // --- Lighting (soft ambient so images show true color) ---
    scene.add(new THREE.AmbientLight(0xffffff, 1));

    // --- Pointer lock for always-live relative movement ---
    const hint = document.getElementById('hint');
    const enterBtn = document.getElementById('enterBtn');

    function requestLock() {
      renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock || renderer.domElement.requestPointerLock;
      renderer.domElement.requestPointerLock();
    }
    enterBtn.addEventListener('click', requestLock);

    document.addEventListener('pointerlockchange', () => {
      const locked = document.pointerLockElement === renderer.domElement;
      document.body.classList.toggle('locked', locked);
      hint.classList.toggle('hidden', locked);
    });

    // --- Movement state (we move the world, not the camera) ---
    let velocityX = 0, velocityZ = 0;
    const SPEED = 1.1;      // base multiplier for mouse delta → world movement
    const FRICTION = 0.9;   // inertia damping per frame (0.9–0.98 feels good)

    // Relative mouse deltas when locked
    window.addEventListener('mousemove', (e) => {
      if (document.pointerLockElement === renderer.domElement) {
        // movementX/Y are relative deltas even when the cursor is hidden/centered
        velocityX += e.movementX * SPEED;
        velocityZ += e.movementY * SPEED; // Y mouse moves world along +Z (downwards visually)
      } else {
        // Fallback (no pointer lock): use deltas from center – weaker to avoid edge trapping
        const dx = e.clientX - innerWidth / 2;
        const dy = e.clientY - innerHeight / 2;
        velocityX += dx * 0.002;
        velocityZ += dy * 0.002;
      }
    });

    // Touch fallback (drag = slide world)
    let lastTouch = null;
    window.addEventListener('touchstart', (e) => { lastTouch = e.touches[0]; }, { passive: true });
    window.addEventListener('touchmove', (e) => {
      const t = e.touches[0];
      if (lastTouch) {
        const dx = t.clientX - lastTouch.clientX;
        const dy = t.clientY - lastTouch.clientY;
        velocityX += dx * (SPEED * 0.8);
        velocityZ += dy * (SPEED * 0.8);
      }
      lastTouch = t;
    }, { passive: true });
    window.addEventListener('touchend', () => { lastTouch = null; }, { passive: true });

    // --- Zoom with wheel (change camera height) ---
    window.addEventListener('wheel', (e) => {
      const delta = Math.sign(e.deltaY);
      camera.position.y = THREE.MathUtils.clamp(camera.position.y + delta * 50, 200, 4000);
      camera.position.z = THREE.MathUtils.clamp(camera.position.z + delta * 30, 300, 6000);
      camera.lookAt(0, 0, 0);
    }, { passive: true });

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // --- Animate: apply velocity with friction to world position ---
    function animate() {
      requestAnimationFrame(animate);

      // Apply movement (move world opposite to mouse direction)
      world.position.x += velocityX;
      world.position.z += velocityZ;

      // Parallax texture scroll so the grid looks continuous
      // (move UVs opposite to world drift to reduce visible tiling seams)
      gridTex.offset.x = (world.position.x / 200000) % 1;
      gridTex.offset.y = (world.position.z / 200000) % 1;

      // Friction
      velocityX *= FRICTION;
      velocityZ *= FRICTION;

      renderer.render(scene, camera);
    }
    animate();

    // Optional: auto-request pointer lock if user clicks anywhere on canvas
    renderer.domElement.addEventListener('click', () => {
      if (document.pointerLockElement !== renderer.domElement) requestLock();
    });
  </script>
</body>
</html>
