<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Infinite Plane Gallery</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: white;
        font-family: sans-serif;
      }
      canvas {
        display: block;
      }
      #overlay {
        position: fixed;
        inset: 0;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        z-index: 10;
      }
      #startBtn {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 1.2rem;
        cursor: pointer;
        border: 2px solid black;
        background: none;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <div>Welcome to the Infinite Plane</div>
      <button id="startBtn">Start</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

    <script>
      let scene, camera, renderer, plane;
      let velocity = new THREE.Vector3();
      let targetVelocity = new THREE.Vector3();
      let isLocked = false;

      init();
      animate();

      function init() {
        scene = new THREE.Scene();

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 5;

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Background grid texture
        const gridCanvas = document.createElement("canvas");
        gridCanvas.width = 256;
        gridCanvas.height = 256;
        const ctx = gridCanvas.getContext("2d");
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, 256, 256);
        ctx.strokeStyle = "rgba(0,0,255,0.3)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= 256; i += 32) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, 256);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(256, i);
          ctx.stroke();
        }
        const gridTexture = new THREE.CanvasTexture(gridCanvas);
        gridTexture.wrapS = THREE.RepeatWrapping;
        gridTexture.wrapT = THREE.RepeatWrapping;
        gridTexture.repeat.set(1000, 1000); // finer grid
        gridTexture.magFilter = THREE.NearestFilter;
        gridTexture.minFilter = THREE.NearestFilter;

        // Plane
        const planeGeo = new THREE.PlaneGeometry(2000, 2000);
        const planeMat = new THREE.MeshBasicMaterial({ map: gridTexture, side: THREE.DoubleSide });
        plane = new THREE.Mesh(planeGeo, planeMat);
        scene.add(plane);

        // Example image planes
        const loader = new THREE.TextureLoader();
        const imageUrls = [
          "https://threejs.org/examples/textures/uv_grid_opengl.jpg",
          "https://threejs.org/examples/textures/flower.jpg",
          "https://threejs.org/examples/textures/brick_diffuse.jpg",
        ];

        imageUrls.forEach((url) => {
          loader.load(url, (texture) => {
            const imgMat = new THREE.MeshBasicMaterial({ map: texture });
            const imgPlane = new THREE.Mesh(new THREE.PlaneGeometry(5, 5), imgMat);
            imgPlane.position.set((Math.random() - 0.5) * 500, (Math.random() - 0.5) * 500, 0.1);
            scene.add(imgPlane);
          });
        });

        // Mouse movement
        document.addEventListener("mousemove", (event) => {
          if (!isLocked) return;
          targetVelocity.x = -event.movementX * 0.05;
          targetVelocity.y = event.movementY * 0.05;
        });

        // Right click toggle pointer lock (mousedown works better than contextmenu)
        document.addEventListener("mousedown", (event) => {
          if (event.button === 2) { // right button
            if (!isLocked) {
              renderer.domElement.requestPointerLock();
            } else {
              document.exitPointerLock();
            }
          }
        });

        document.addEventListener("pointerlockchange", () => {
          isLocked = document.pointerLockElement === renderer.domElement;
        });

        // Resize
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Overlay start
        const overlay = document.getElementById("overlay");
        document.getElementById("startBtn").addEventListener("click", () => {
          overlay.style.display = "none";
        });
      }

      function animate() {
        requestAnimationFrame(animate);

        // Apply smoother friction
        velocity.lerp(targetVelocity, 0.2);
        plane.position.x += velocity.x;
        plane.position.y += velocity.y;

        targetVelocity.multiplyScalar(0.85); // friction
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
